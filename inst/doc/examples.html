<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Generating a metacommunity</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Generating a metacommunity</h2>

<p>Before calculating diversity a <code>metacommunity</code> object must be created. This object contains all the information needed to calculate diversity. In the following example, we generate a metacommunity (<code>partition</code>) comprising two species (&ldquo;cows&rdquo; and &ldquo;sheep&rdquo;), and partitioned across three subcommunities (a, b, and c).</p>

<pre><code class="r"># Load the package into R
library(rdiversity)

# Initialise data
partition &lt;- data.frame(a=c(1,1),b=c(2,0),c=c(3,1))
row.names(partition) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)
</code></pre>

<p>The <code>metacommunity()</code> function takes two arguments, <code>partition</code> and <code>similarity</code>. When species are considered completely distinct, an identity matrix is required, which is generated automatically if the <code>similarity</code> argument is missing, as below:</p>

<pre><code class="r"># Generate metacommunity object
meta &lt;- metacommunity(partition = partition)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<p>Note that a warning is displayed when abundances (rather than relative abundances) are entered into the <code>partition</code> argument. Both are acceptable inputs.</p>

<p>When species share some similarity and a similarity matrix is available, then a similarity object (and the metacommunity object) is generated in the following way:</p>

<pre><code class="r"># Initialise similarity matrix
s &lt;- matrix(c(1, 0.5, 0.5, 1), nrow = 2)
row.names(s) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)
colnames(s) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)

# Generate similarity object 
s &lt;- similarity(similarity = s, dat_id = &quot;my_taxonomic&quot;)

# Generate metacommunity object
meta &lt;- metacommunity(partition = partition, similarity = s)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<p>Alternatively, if a distance matrix is available, then a distance object is generated in the following way: </p>

<pre><code class="r"># Initialise distance matrix
d &lt;- matrix(c(0, 0.7, 0.7, 0), nrow = 2)
row.names(d) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)
colnames(d) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)

# Generate distance object
d &lt;- distance(distance = d, dat_id = &quot;my_taxonomic&quot;)

# Convert the distance object to similarity object (by means of a linear or exponential transform)
s &lt;- dist2sim(dist = d, transform = &quot;linear&quot;)

# Generate metacommunity object
meta &lt;- metacommunity(partition = partition, similarity = s)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<p>Each <code>metacommunity</code> object contains the following slots:</p>

<ul>
<li><code>@type_abundance</code> : the abundance of types within a metacommunity,<br/></li>
<li><code>@similarity</code> : the pair-wise similarity of types within a metacommunity,<br/></li>
<li><code>@ordinariness</code> : the ordinariness of types within a metacommunity,<br/></li>
<li><code>@subcommunity_weights</code> :  the relative weights of subcommunities within a metacommunity, and</li>
<li><code>@type_weights</code> : the relative weights of types within a metacommunity.</li>
</ul>

<h2>Calculating diversity</h2>

<h3>Method 1</h3>

<p>This method uses a wrapper function to simplify the pipeline and is recommended if only a few measures are being calculated.</p>

<p>A complete list of these functions is shown below:</p>

<ul>
<li><code>raw_sub_alpha()</code> : estimate of naive-community metacommunity diversity<br/></li>
<li><code>norm_sub_alpha()</code> : similarity-sensitive diversity of subcommunity <em>j</em> in isolation<br/></li>
<li><code>raw_sub_rho()</code> : redundancy of subcommunity <em>j</em><br/></li>
<li><code>norm_sub_rho()</code> : representativeness of subcommunity <em>j</em><br/></li>
<li><code>raw_sub_beta()</code> : distinctiveness of subcommunity <em>j</em><br/></li>
<li><code>norm_sub_beta()</code> : estimate of effective number of distinct subcommunities<br/></li>
<li><code>sub_gamma()</code> : contribution per individual toward metacommunity diversity<br/></li>
<li><code>raw_meta_alpha()</code> : naive-community metacommunity diversity<br/></li>
<li><code>norm_meta_alpha()</code> : average similarity-sensitive diversity of subcommunities<br/></li>
<li><code>raw_meta_rho()</code> : average redundancy of subcommunities<br/></li>
<li><code>norm_meta_rho()</code> : average representativeness of subcommunities<br/></li>
<li><code>raw_meta_beta()</code> : average distinctiveness of subcommunities<br/></li>
<li><code>norm_meta_beta()</code> : effective number of distinct subcommunities<br/></li>
<li><code>meta_gamma()</code> : metacommunity similarity-sensitive diversity<br/></li>
</ul>

<p>Each of these functions take two arguments, <code>meta</code> (a <code>metacommunity</code> object) and <code>qs</code> (a vector of q values), and output results as a <code>rdiv</code> object. For example, to calculate normalised subcommunity alpha diversity for <em>q=0</em>, <em>q=1</em>, and <em>q=2</em>:</p>

<pre><code class="r"># Initialise data
partition &lt;- data.frame(a=c(1,1),b=c(2,0),c=c(3,1))
row.names(partition) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)

# Generate a metacommunity object
meta &lt;- metacommunity(partition)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<pre><code class="r"># Calculate diversity
norm_sub_alpha(meta, 0:2)
</code></pre>

<pre><code>##            measure q type_level type_name partition_level partition_name
## 1 normalised alpha 0      types              subcommunity              a
## 2 normalised alpha 0      types              subcommunity              b
## 3 normalised alpha 0      types              subcommunity              c
## 4 normalised alpha 1      types              subcommunity              a
## 5 normalised alpha 1      types              subcommunity              b
## 6 normalised alpha 1      types              subcommunity              c
## 7 normalised alpha 2      types              subcommunity              a
## 8 normalised alpha 2      types              subcommunity              b
## 9 normalised alpha 2      types              subcommunity              c
##   diversity dat_id transformation normalised  k max_d
## 1  2.000000  naive             NA         NA NA    NA
## 2  1.000000  naive             NA         NA NA    NA
## 3  2.000000  naive             NA         NA NA    NA
## 4  2.000000  naive             NA         NA NA    NA
## 5  1.000000  naive             NA         NA NA    NA
## 6  1.754765  naive             NA         NA NA    NA
## 7  2.000000  naive             NA         NA NA    NA
## 8  1.000000  naive             NA         NA NA    NA
## 9  1.600000  naive             NA         NA NA    NA
</code></pre>

<p>However, if multiple measures are required and computational efficiency is an issue, then the following method is recommended (the same results are obtained).</p>

<h3>Method 2</h3>

<p>This method requires that we first calculate the species-level components, by passing a <code>metacommunity</code> object to the appropriate function; <code>raw_alpha()</code>, <code>norm_alpha()</code>, <code>raw_beta()</code>, <code>norm_beta()</code>, <code>raw_rho()</code>, <code>norm_rho()</code>, or <code>raw_gamma()</code>. Subcommunity- and metacommunity-level diversities are calculated using the functions <code>subdiv()</code> and <code>metadiv()</code>. Since both subcommunity and metacommunity diversity measures are transformations of the same species-level component, this method is computationally more efficient.</p>

<pre><code class="r"># Initialise data
partition &lt;- data.frame(a=c(1,1),b=c(2,0),c=c(3,1))
row.names(partition) &lt;- c(&quot;cows&quot;, &quot;sheep&quot;)

# Generate a metacommunity object
meta &lt;- metacommunity(partition)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<pre><code class="r"># Calculate the species-level component for normalised alpha
component &lt;- norm_alpha(meta)

# Calculate normalised alpha at the subcommunity-level 
subdiv(component, 0:2)
</code></pre>

<pre><code>##            measure q type_level type_name partition_level partition_name
## 1 normalised alpha 0      types              subcommunity              a
## 2 normalised alpha 0      types              subcommunity              b
## 3 normalised alpha 0      types              subcommunity              c
## 4 normalised alpha 1      types              subcommunity              a
## 5 normalised alpha 1      types              subcommunity              b
## 6 normalised alpha 1      types              subcommunity              c
## 7 normalised alpha 2      types              subcommunity              a
## 8 normalised alpha 2      types              subcommunity              b
## 9 normalised alpha 2      types              subcommunity              c
##   diversity dat_id transformation normalised  k max_d
## 1  2.000000  naive             NA         NA NA    NA
## 2  1.000000  naive             NA         NA NA    NA
## 3  2.000000  naive             NA         NA NA    NA
## 4  2.000000  naive             NA         NA NA    NA
## 5  1.000000  naive             NA         NA NA    NA
## 6  1.754765  naive             NA         NA NA    NA
## 7  2.000000  naive             NA         NA NA    NA
## 8  1.000000  naive             NA         NA NA    NA
## 9  1.600000  naive             NA         NA NA    NA
</code></pre>

<pre><code class="r"># Likewise, calculate normalised alpha at the metacommunity-level 
metadiv(component, 0:2)
</code></pre>

<pre><code>##            measure q type_level type_name partition_level partition_name
## 1 normalised alpha 0      types             metacommunity               
## 2 normalised alpha 1      types             metacommunity               
## 3 normalised alpha 2      types             metacommunity               
##   diversity dat_id transformation normalised  k max_d
## 1  1.750000  naive             NA         NA NA    NA
## 2  1.575314  naive             NA         NA NA    NA
## 3  1.454545  naive             NA         NA NA    NA
</code></pre>

<p>In some instances, it may be useful to calculate <strong>all</strong> subcommunity (or metacommunity) measures. In which case, a <code>metacommunity</code> object may be passed directly to <code>subdiv()</code> or <code>metadiv()</code>:</p>

<pre><code class="r"># Calculate all subcommunity diversity measures
subdiv(meta, 0:2)
</code></pre>

<pre><code>##             measure q type_level type_name partition_level partition_name
## 1         raw alpha 0      types              subcommunity              a
## 2         raw alpha 0      types              subcommunity              b
## 3         raw alpha 0      types              subcommunity              c
## 4         raw alpha 1      types              subcommunity              a
## 5         raw alpha 1      types              subcommunity              b
## 6         raw alpha 1      types              subcommunity              c
## 7         raw alpha 2      types              subcommunity              a
## 8         raw alpha 2      types              subcommunity              b
## 9         raw alpha 2      types              subcommunity              c
## 10 normalised alpha 0      types              subcommunity              a
## 11 normalised alpha 0      types              subcommunity              b
## 12 normalised alpha 0      types              subcommunity              c
## 13 normalised alpha 1      types              subcommunity              a
## 14 normalised alpha 1      types              subcommunity              b
## 15 normalised alpha 1      types              subcommunity              c
## 16 normalised alpha 2      types              subcommunity              a
## 17 normalised alpha 2      types              subcommunity              b
## 18 normalised alpha 2      types              subcommunity              c
## 19         raw beta 0      types              subcommunity              a
## 20         raw beta 0      types              subcommunity              b
## 21         raw beta 0      types              subcommunity              c
## 22         raw beta 1      types              subcommunity              a
## 23         raw beta 1      types              subcommunity              b
## 24         raw beta 1      types              subcommunity              c
## 25         raw beta 2      types              subcommunity              a
## 26         raw beta 2      types              subcommunity              b
## 27         raw beta 2      types              subcommunity              c
## 28  normalised beta 0      types              subcommunity              a
## 29  normalised beta 0      types              subcommunity              b
## 30  normalised beta 0      types              subcommunity              c
## 31  normalised beta 1      types              subcommunity              a
## 32  normalised beta 1      types              subcommunity              b
## 33  normalised beta 1      types              subcommunity              c
## 34  normalised beta 2      types              subcommunity              a
## 35  normalised beta 2      types              subcommunity              b
## 36  normalised beta 2      types              subcommunity              c
## 37          raw rho 0      types              subcommunity              a
## 38          raw rho 0      types              subcommunity              b
## 39          raw rho 0      types              subcommunity              c
## 40          raw rho 1      types              subcommunity              a
## 41          raw rho 1      types              subcommunity              b
## 42          raw rho 1      types              subcommunity              c
## 43          raw rho 2      types              subcommunity              a
## 44          raw rho 2      types              subcommunity              b
## 45          raw rho 2      types              subcommunity              c
## 46   normalised rho 0      types              subcommunity              a
## 47   normalised rho 0      types              subcommunity              b
## 48   normalised rho 0      types              subcommunity              c
## 49   normalised rho 1      types              subcommunity              a
## 50   normalised rho 1      types              subcommunity              b
## 51   normalised rho 1      types              subcommunity              c
## 52   normalised rho 2      types              subcommunity              a
## 53   normalised rho 2      types              subcommunity              b
## 54   normalised rho 2      types              subcommunity              c
## 55            gamma 0      types              subcommunity              a
## 56            gamma 0      types              subcommunity              b
## 57            gamma 0      types              subcommunity              c
## 58            gamma 1      types              subcommunity              a
## 59            gamma 1      types              subcommunity              b
## 60            gamma 1      types              subcommunity              c
## 61            gamma 2      types              subcommunity              a
## 62            gamma 2      types              subcommunity              b
## 63            gamma 2      types              subcommunity              c
##    diversity dat_id transformation normalised  k max_d
## 1  8.0000000  naive             NA         NA NA    NA
## 2  4.0000000  naive             NA         NA NA    NA
## 3  4.0000000  naive             NA         NA NA    NA
## 4  8.0000000  naive             NA         NA NA    NA
## 5  4.0000000  naive             NA         NA NA    NA
## 6  3.5095307  naive             NA         NA NA    NA
## 7  8.0000000  naive             NA         NA NA    NA
## 8  4.0000000  naive             NA         NA NA    NA
## 9  3.2000000  naive             NA         NA NA    NA
## 10 2.0000000  naive             NA         NA NA    NA
## 11 1.0000000  naive             NA         NA NA    NA
## 12 2.0000000  naive             NA         NA NA    NA
## 13 2.0000000  naive             NA         NA NA    NA
## 14 1.0000000  naive             NA         NA NA    NA
## 15 1.7547654  naive             NA         NA NA    NA
## 16 2.0000000  naive             NA         NA NA    NA
## 17 1.0000000  naive             NA         NA NA    NA
## 18 1.6000000  naive             NA         NA NA    NA
## 19 0.2500000  naive             NA         NA NA    NA
## 20 0.3333333  naive             NA         NA NA    NA
## 21 0.5000000  naive             NA         NA NA    NA
## 22 0.2886751  naive             NA         NA NA    NA
## 23 0.3333333  naive             NA         NA NA    NA
## 24 0.5000000  naive             NA         NA NA    NA
## 25 0.3333333  naive             NA         NA NA    NA
## 26 0.3333333  naive             NA         NA NA    NA
## 27 0.5000000  naive             NA         NA NA    NA
## 28 1.0000000  naive             NA         NA NA    NA
## 29 1.3333333  naive             NA         NA NA    NA
## 30 1.0000000  naive             NA         NA NA    NA
## 31 1.1547005  naive             NA         NA NA    NA
## 32 1.3333333  naive             NA         NA NA    NA
## 33 1.0000000  naive             NA         NA NA    NA
## 34 1.3333333  naive             NA         NA NA    NA
## 35 1.3333333  naive             NA         NA NA    NA
## 36 1.0000000  naive             NA         NA NA    NA
## 37 4.0000000  naive             NA         NA NA    NA
## 38 3.0000000  naive             NA         NA NA    NA
## 39 2.0000000  naive             NA         NA NA    NA
## 40 3.4641016  naive             NA         NA NA    NA
## 41 3.0000000  naive             NA         NA NA    NA
## 42 2.0000000  naive             NA         NA NA    NA
## 43 3.0000000  naive             NA         NA NA    NA
## 44 3.0000000  naive             NA         NA NA    NA
## 45 2.0000000  naive             NA         NA NA    NA
## 46 1.0000000  naive             NA         NA NA    NA
## 47 0.7500000  naive             NA         NA NA    NA
## 48 1.0000000  naive             NA         NA NA    NA
## 49 0.8660254  naive             NA         NA NA    NA
## 50 0.7500000  naive             NA         NA NA    NA
## 51 1.0000000  naive             NA         NA NA    NA
## 52 0.7500000  naive             NA         NA NA    NA
## 53 0.7500000  naive             NA         NA NA    NA
## 54 1.0000000  naive             NA         NA NA    NA
## 55 2.6666667  naive             NA         NA NA    NA
## 56 1.3333333  naive             NA         NA NA    NA
## 57 2.0000000  naive             NA         NA NA    NA
## 58 2.3094011  naive             NA         NA NA    NA
## 59 1.3333333  naive             NA         NA NA    NA
## 60 1.7547654  naive             NA         NA NA    NA
## 61 2.0000000  naive             NA         NA NA    NA
## 62 1.3333333  naive             NA         NA NA    NA
## 63 1.6000000  naive             NA         NA NA    NA
</code></pre>

<pre><code class="r"># Calculate all metacommunity diversity measures
metadiv(meta, 0:2)
</code></pre>

<pre><code>##             measure q type_level type_name partition_level partition_name
## 1         raw alpha 0      types             metacommunity               
## 2         raw alpha 1      types             metacommunity               
## 3         raw alpha 2      types             metacommunity               
## 4  normalised alpha 0      types             metacommunity               
## 5  normalised alpha 1      types             metacommunity               
## 6  normalised alpha 2      types             metacommunity               
## 7          raw beta 0      types             metacommunity               
## 8          raw beta 1      types             metacommunity               
## 9          raw beta 2      types             metacommunity               
## 10  normalised beta 0      types             metacommunity               
## 11  normalised beta 1      types             metacommunity               
## 12  normalised beta 2      types             metacommunity               
## 13          raw rho 0      types             metacommunity               
## 14          raw rho 1      types             metacommunity               
## 15          raw rho 2      types             metacommunity               
## 16   normalised rho 0      types             metacommunity               
## 17   normalised rho 1      types             metacommunity               
## 18   normalised rho 2      types             metacommunity               
## 19            gamma 0      types             metacommunity               
## 20            gamma 1      types             metacommunity               
## 21            gamma 2      types             metacommunity               
##    diversity dat_id transformation normalised  k max_d
## 1  5.0000000  naive             NA         NA NA    NA
## 2  4.4556597  naive             NA         NA NA    NA
## 3  4.0000000  naive             NA         NA NA    NA
## 4  1.7500000  naive             NA         NA NA    NA
## 5  1.5753136  naive             NA         NA NA    NA
## 6  1.4545455  naive             NA         NA NA    NA
## 7  0.3958333  naive             NA         NA NA    NA
## 8  0.3938284  naive             NA         NA NA    NA
## 9  0.4000000  naive             NA         NA NA    NA
## 10 1.0833333  naive             NA         NA NA    NA
## 11 1.1139149  naive             NA         NA NA    NA
## 12 1.1428571  naive             NA         NA NA    NA
## 13 2.7500000  naive             NA         NA NA    NA
## 14 2.5391770  naive             NA         NA NA    NA
## 15 2.4000000  naive             NA         NA NA    NA
## 16 0.9375000  naive             NA         NA NA    NA
## 17 0.8977346  naive             NA         NA NA    NA
## 18 0.8571429  naive             NA         NA NA    NA
## 19 2.0000000  naive             NA         NA NA    NA
## 20 1.7547654  naive             NA         NA NA    NA
## 21 1.6000000  naive             NA         NA NA    NA
</code></pre>

<h2>Taxonomic diversity</h2>

<ol>
<li>Initialise data:</li>
</ol>

<pre><code class="r"># Taxonomic lookup table
Species &lt;- c(&quot;tenuifolium&quot;, &quot;asterolepis&quot;, &quot;simplex var.grandiflora&quot;, &quot;simplex var.ochnacea&quot;)
Genus &lt;- c(&quot;Protium&quot;, &quot;Quararibea&quot;, &quot;Swartzia&quot;, &quot;Swartzia&quot;)
Family &lt;- c(&quot;Burseraceae&quot;, &quot;Bombacaceae&quot;, &quot;Fabaceae&quot;, &quot;Fabaceae&quot;)
Subclass &lt;- c(&quot;Sapindales&quot;, &quot;Malvales&quot;, &quot;Fabales&quot;, &quot;Fabales&quot;)
lookup &lt;- cbind.data.frame(Species, Genus, Family, Subclass)

# Partition matrix
partition &lt;- matrix(rep(1, 8), nrow = 4)
colnames(partition) &lt;- LETTERS[1:2]
rownames(partition) &lt;- lookup$Species
</code></pre>

<p>and assign values for each taxonomic level:</p>

<pre><code class="r">values &lt;- c(Species = 0, Genus = 1, Family = 2, Subclass = 3, Other = 4)
</code></pre>

<ol>
<li>Generate a distance object from a lookup table using the <code>tax2dist()</code> 
function:</li>
</ol>

<pre><code class="r">d &lt;- tax2dist(lookup, values)
</code></pre>

<p>By default the <code>tax2dist()</code> argument <code>precompute_dist</code> is TRUE, such that a pairwise distance matrix is calculated automatically and is stored in <code>d@distance</code>. If the taxonomy is too large, <code>precompute_dist</code> can be set to FALSE, which enables pairwise taxonomic similarity to be calculated on the fly, in step 4. </p>

<ol>
<li>Convert the distance object to similarity object (by means of a linear or exponential transform) using the <code>dist2sim()</code> function:</li>
</ol>

<pre><code class="r">s &lt;- dist2sim(d, &quot;linear&quot;)
</code></pre>

<ol>
<li>Generate a metacommunity object using the <code>metacommunity()</code> function:</li>
</ol>

<pre><code class="r">meta &lt;- metacommunity(partition, s)
</code></pre>

<pre><code>## Metacommunity matrix was normalised to sum to 1.
</code></pre>

<ol>
<li>Calculate diversity:</li>
</ol>

<pre><code class="r">meta_gamma(meta, 0:2)
</code></pre>

<pre><code>##   measure q type_level type_name partition_level partition_name diversity
## 1   gamma 0      types             metacommunity                 3.142857
## 2   gamma 1      types             metacommunity                 3.023716
## 3   gamma 2      types             metacommunity                 2.909091
##      dat_id transformation normalised k max_d
## 1 taxonomic         linear       TRUE 1     4
## 2 taxonomic         linear       TRUE 1     4
## 3 taxonomic         linear       TRUE 1     4
</code></pre>

<h2>Phylogenetic diversity</h2>

<p>Phylogenetic diversity measures can be broadly split into two categories – those that look at the phylogeny as a whole, such as Faith’s (1992) phylogenetic diversity (Faith’s PD), and those that look at pairwise tip distances, such as mean pairwise distance (MPD; Webb, 2000). The framework of measures presented in this package is able to quantify phylogenetic diversity using both of these methods.</p>

<h3>Distance-based phylogenetic diversity</h3>

<ol>
<li>Initialise data:</li>
</ol>

<pre><code class="r"># Example data
tree &lt;- ape::rtree(4)
partition &lt;- matrix(1:12, ncol=3)
partition &lt;- partition/sum(partition)
</code></pre>

<ol>
<li>Generate a distance matrix using the <code>phy2dist()</code> function: </li>
</ol>

<pre><code class="r">d &lt;- phy2dist(tree)
</code></pre>

<p>By default the <code>phy2dist()</code> argument <code>precompute_dist</code> is TRUE, such that a pairwise distance matrix is calculated automatically and is stored in <code>d@distance</code>. If the taxonomy is too large, <code>precompute_dist</code> can be set to FALSE, which enables pairwise taxonomic similarity to be calculated on the fly, in step 4. </p>

<ol>
<li>Convert the distance object to similarity object (by means of a linear or exponential transform) using the <code>dist2sim()</code> function:</li>
</ol>

<pre><code class="r">s &lt;- dist2sim(d, &quot;linear&quot;)
</code></pre>

<ol>
<li>Generate a metacommunity object using the <code>metacommunity()</code> function</li>
</ol>

<pre><code class="r">meta &lt;- metacommunity(partition, s)
</code></pre>

<ol>
<li>Calculate diversity</li>
</ol>

<pre><code class="r">meta_gamma(meta, 0:2)
</code></pre>

<pre><code>##   measure q type_level type_name partition_level partition_name diversity
## 1   gamma 0      types             metacommunity                 2.506940
## 2   gamma 1      types             metacommunity                 2.459285
## 3   gamma 2      types             metacommunity                 2.414723
##         dat_id transformation normalised k    max_d
## 1 phylogenetic         linear       TRUE 1 1.796924
## 2 phylogenetic         linear       TRUE 1 1.796924
## 3 phylogenetic         linear       TRUE 1 1.796924
</code></pre>

<h3>Branch-based phylogenetic diversity</h3>

<ol>
<li>Initialise data:</li>
</ol>

<pre><code class="r">tree &lt;- ape::rtree(4)
partition &lt;- matrix(1:12, ncol=3)
partition &lt;- partition/sum(partition)
colnames(partition) &lt;- letters[1:3]
row.names(partition) &lt;- paste0(&quot;sp&quot;,1:4)
tree$tip.label &lt;- row.names(partition)
</code></pre>

<ol>
<li>Generate a similarity object using the <code>phy2branch()</code> function</li>
</ol>

<pre><code class="r">s &lt;- phy2branch(tree, partition)
</code></pre>

<ol>
<li>Generate a metacommunity object using the <code>metacommunity()</code> function</li>
</ol>

<pre><code class="r">meta &lt;- metacommunity(partition, s)
</code></pre>

<ol>
<li>Calculate diversity</li>
</ol>

<pre><code class="r">meta_gamma(meta, 0:2)
</code></pre>

<pre><code>##   measure q type_level type_name partition_level partition_name diversity
## 1   gamma 0      types             metacommunity                 2.483452
## 2   gamma 1      types             metacommunity                 2.286031
## 3   gamma 2      types             metacommunity                 2.118287
##      dat_id transformation normalised  k max_d
## 1 phybranch             NA         NA NA    NA
## 2 phybranch             NA         NA NA    NA
## 3 phybranch             NA         NA NA    NA
</code></pre>

<p><strong>Note that</strong>: a metacommunity that was generated using this approach will contain three additional slots:</p>

<ul>
<li><code>@raw_abundance</code> : the relative abundance of terminal species (where types are then considered to be historical species),</li>
<li><code>@raw_structure</code> : the length of evolutionary history of each historical species</li>
<li><code>@parameters</code> : parameters associated with historical species</li>
</ul>

<h2>Genetic diversity</h2>

<ol>
<li>Initialise data:
Note: the package <code>pinfsc50</code> must be installed for this example to work.</li>
</ol>

<pre><code class="r">library(rdiversity)
vcf_file &lt;- system.file(&quot;extdata&quot;, &quot;pinf_sc50.vcf.gz&quot;, package = &quot;pinfsc50&quot;)
#read in twice: first for the column names then for the data
tmp_vcf &lt;- readLines(vcf_file)
vcf_data &lt;- read.table(vcf_file, stringsAsFactors = FALSE)
# filter for the columns names
vcf_names &lt;- unlist(strsplit(tmp_vcf[grep(&quot;#CHROM&quot;,tmp_vcf)],&quot;\t&quot;))
names(vcf_data) &lt;- vcf_names
partition &lt;- cbind.data.frame(A = c(rep(1, 9), rep(0, 9)), B = c(rep(0, 9), rep(1, 9)))
partition &lt;- partition/sum(partition)
</code></pre>

<ol>
<li>Generate a distance matrix using the <code>gen2dist()</code> function:</li>
</ol>

<pre><code class="r">d &lt;- gen2dist(vcf)
</code></pre>

<ol>
<li>Convert the distance object to a similarity object (by means of a linear or exponential transform) using the <code>dist2sim()</code> function:</li>
</ol>

<pre><code class="r">s &lt;- dist2sim(d, transform = &#39;l&#39;)
</code></pre>

<p>Note: the <code>dist2sim()</code> function contains an optional argument, <code>max_d</code>, which defines the distance at which pairs of individuals have similarity zero. If not supplied this is set to the maximum distance observed in the distance matrix. If comparing different windows on a genome, for example, it is necessary to ensure <code>max_d</code> is the same for each analysis.</p>

<ol>
<li>Generate a metacommunity object using the <code>metacommunity()</code> function:</li>
</ol>

<pre><code class="r">rownames(partition) &lt;- rownames(s@similarity)
meta &lt;- metacommunity(partition, s)
</code></pre>

<ol>
<li>Calculate diversity, for example beta diversity measures are used to identify trends such as differentiation:</li>
</ol>

<pre><code class="r">norm_meta_beta(meta, 0:2)
</code></pre>

<h3>User defined distance</h3>

<pre><code class="r">partition &lt;- matrix(sample(6), nrow = 3)
rownames(partition) &lt;- paste0(&quot;sp&quot;, 1:3)
partition &lt;- partition / sum(partition)

d &lt;- matrix(c(0,.75,1,.75,0,.3,1,.3,0), nrow = 3)
rownames(d) &lt;- paste0(&quot;sp&quot;, 1:3)
colnames(d) &lt;- paste0(&quot;sp&quot;, 1:3)
d &lt;- distance(d, &quot;my_taxonomy&quot;)
s &lt;- dist2sim(d, &quot;linear&quot;)

meta &lt;- metacommunity(partition, s)
</code></pre>

<h3>User defined similarity</h3>

<pre><code class="r">partition &lt;- matrix(sample(6), nrow = 3)
rownames(partition) &lt;- paste0(&quot;sp&quot;, 1:3)
partition &lt;- partition / sum(partition)

s &lt;- matrix(c(1,.8,0,.8,1,.1,0,.1,1), nrow = 3)
rownames(s) &lt;- paste0(&quot;sp&quot;, 1:3)
colnames(s) &lt;- paste0(&quot;sp&quot;, 1:3)
s &lt;- similarity(s, &quot;my_functional&quot;)

meta &lt;- metacommunity(partition, s)
</code></pre>

<h2>Additional tools</h2>

<h3><code>repartition()</code></h3>

<pre><code class="r">tree &lt;- ape::rtree(5)
tree$tip.label &lt;- paste0(&quot;sp&quot;, 1:5)

partition &lt;- matrix(rep(1,10), nrow = 5)
row.names(partition) &lt;- paste0(&quot;sp&quot;, 1:5)
partition &lt;- partition / sum(partition)
s &lt;- phy2branch(tree, partition)
meta &lt;- metacommunity(partition, s)

new_partition &lt;- matrix(sample(10), nrow = 5)
row.names(new_partition) &lt;- paste0(&quot;sp&quot;, 1:5)
new_partition &lt;- new_partition / sum(new_partition)

new_meta &lt;- repartition(meta, new_partition)
</code></pre>

</body>

</html>
